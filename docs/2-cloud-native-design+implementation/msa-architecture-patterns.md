---
id: MSA Architecture Patterns
sidebar_position: 1
sidebar_label: MSA Architecture Patterns
---

A number of patterns and best practices have been defined for microservice architectures; however Chris Richardson
provides a great overview and illustration of these at his website https://microservices.io/. A cut-down version of this to illustrate those considered for The Better Store are shown below:

![Micoservice Patterns in-scope for The Better Store ](msa-patterns.svg)

A description of those used and why by The Better Store are described below.

## Application Patterns
### Decomposition
**Decompose By Subdomain** describes how Domain Driven Design may be used to decompose a business's domain into decoupled subdomains or *Bounded Contexts*, each of which may be considered as a candidate for a microservice implementation. This topic has been the focus of our previous articles in this series.  

**Self Contained Service** describes how each service should own and define all of their application and infrastructure dependencies such as data storage, security resources etc; such that they can be deployed quickly and independently across environments. This includes for example having their own security roles, firewall definitions, databases (see below), SSL certificates and domain records defined; external/shared dependencies are kept to a minimum; such as the VPC in which they reside.
In the next DecSecOps section, *Infrastructure as Code (IaC)* using AWS Cloudformation will be described, for the creation of fully-encapsulated Cloudformation stacks which may be used to deploy instances of independent microservices, including resources that they require.

The example below illustrates the Order Cloudforamtion stack, which defines all of its required resources, and shared infrastructure stacks that it depends on.

![Self-contained order stack example ](order-stack.svg)

**Onion Architecture**, while not being strictly specific to microservices, is a highly-recommended pattern used by The Better Store for implementing services having a layered architecture oriented towards defining domain services at their core, with decoupled outer layers using SOLID paradigms to encapsulate application services including persistence, authentication, logging, and other external dependencies. Its key advantages include optimising code structure for maintainability, extensibility and testing. The Onion Architecture is described in further detail in the previous DDD Strategic Patterns section.

### Data Patterns

#### Database Architecture

**Database per Service** is an often contentious pattern recommended for microservices; traditional relational databases can often become large in size to accommodate a data model shared by multiple application services, where relational constraints and supporting of atomic transactions across tables that may be shared by multiple services are enforced to preserve data integrity. Imposing the database/service pattern implies the following:
1. The database is split into objects specific for each microservice, which means breaking relational constraints and ACID transaction support otherwise provided.
2. The application's architecture needs to be refactored to cater for the loss of these constraints to preserve data integrity. Patterns that may assist include 'Aggregate', 'Saga', and 'Idempotent Consumer', to be introduced below.

Advantages of the Database per Service again is *change agility*; any changes that may be required to a database should generally only impact its owning microservice. This greatly-reduces the risk of issues and the amount of regression testing
that may otherwise be required when making changes. Furthermore, each service is free to use a database technology that is most suitable for their needs, aka *(polyglot persistence)*, for example:

* The Order microservice is expected to use AWS DynamoDB, a serverless NoSQL database which scales well for high-demand, and is capable of replicating data across regions for potential future global scalability of the application.
* The Reports microservice is expected to use AWS Aurora Serverless, to receive orders in batches, which supports complex relational queries using SQL to provide overnight reports. Its serverless nature is expected to provide cost optimisation for its low intended traffic, while any cold-starts in activity will not impact users.

#### Data Consistency

The **Saga** pattern addresses the problem of how to manage business transactions that span multiple databases, for example when implementing the Database per Service pattern described above and database *2-phase commits* and rollbacks are not possible. It describes
a process whereby such transactions are implemented as a sequence of partial transactions against each of the participant databases. If any single step of the trasnaction fails, then previous changes are to be rolled-back by running copensating transactions in the reverse order.

An example of a choreography-based saga is given below (where system behaviour is asynchronously event-driven):

![Saga Choreography](saga-choreography.svg)


#### Querying

**CQRS** 




## Summary
#### Application Patterns

| **Pattern**            | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Notes                                                                                                                                                                                    |
|:-----------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| _Decomposition_        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Completed as per our DDD                                                                                                                                                                 |
| Domain Driven Design   | As per our previous sections, we are using Domain Driven Design to formulate appropriate decomposition of services to business capabilities or _subdomains_. We will focus on the Order, Fulfillment and Reporting domains for the above example.                                                                                                                                                                                                                                                                                       | We will use AWS Cloudformation to define a 'stack' for each service and its dependencies, to be described in the next section                                                            |
| Self-contained Service | Services own and define all of their application and infrastructure dependencies such as data storage, security resources etc; such that they can be deployed quickly and independently across environments. This includes for example having their own security roles, firewall definitions, databases (see below), SSL certificates and domain records defined; external/shared dependencies are kept to a minimum; such as the VPC in which they reside.                                                                             | N/A                                                                                                                                                                                      |
| Onion Architecture     | As used by The Better Store to split application logic into separate abstract layers, to promote code-level decoupling and object-orienteed programming techniques such as polymorphic interfaces, for easier future maintenance, extension and testability of code. Other popular designs include Hegaxonal Architecture and SOLID. Discussion of these is outside of the scope of these articles however. 
| _Data Patterns_        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                          |
| Database per Service   | Implementing a database specific to a service helps promote system agility via cohesion and decoupling of services, and minimising their external dependencies. This is in-contrast to implementing a 'shared database', which while may provide a simpler system design including for transaction management and defining wider data relationships, change agility becomes reduced while database changes may impact all connected services.                                                                                           | Each service may implement its own datastore, using the most appropriate technology (e.g. Sql or NoSQL)                                                                                  |
| API Composition        | While microservices serve a specific subdomain for sending, receiving and processing of data, it is very common that clients may wish to query data that span multiple related services; e.g. both Order and Product services to provide inventory details of an order. API's may by created to serve a client, by implementing endpoints (e.g. 'GET /orderdetails' that can span multiple services and aggregate the results to return to the client. This greatly reduces the complexity and domain knowledge required by the client. | AWS API Gateway will be used as a proxy for HTTPS services, which may provide security (authentication and authorisation), throttling, caching and request/response translation services |
| CQRS                   | To promote scalability and resilience of a service's communications with a database, the Command and Query Responsibility Segregation is promoted, whereby writing of data to a database is performed separately and asynchronously (using 'eventual consistency') from synchronous read operations to the database. This will be described in further depth later.                                                                                                                                                                     |                                                                                                                                                                                          |
| Saga                   | Methodology that allows a distributed data transaction spanning multiple databases (or other data stores) to be rolled-back via compensatory actions. Note this becomes a necessary complexity for microservice architectures when a shared database is not used, in favour of agility.                                                                                                                                                                                                                                                 |                                                                                                                                                                                          |


##### Application Infrastructure Patterns

| **Pattern**                                     | Description                                                                                                                                                                                                                                                                                                                            | Notes                                                                                                |
|:------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|
| _Cross-cutting concerns_                        |                                                                                                                                                                                                                                                                                                                                        |                                                                                                      |
| Externalized configuration                      |                                                                                                                                                                                                                                                                                                                                        | To be implemented using AWS SSM ParameterStore, AWS SecretsManager                                   |
| _Communication Style_                           |                                                                                                                                                                                                                                                                                                                                        |                                                                                                      |
| Messaging (asynchronous)                        | A message channel is used by a service for sending messages to a destination, where an immediate response is not required. This pattern provides system resilience, by catering for cases where a destination system may be slow to response or temporarily unavailable. Examples include Email, and messages queues.                  | AWS SNS, AWS SQS, AWS EventBridge                                                                    |
| Remote Procedure Invocation (RPC) (synchronous) | Describes calls from a service to a destination where an immediate response is expected. Examples include HTTP(S) invocations.                                                                                                                                                                                                         | AWS SDK                                                                                              |
 | Idempotent Consumer                            | Describes how services should be able to handle receiving duplicate requests without causing side-effect to the system. This is particulary-important to cater for "At-Least-Once Delivery" of some message transport resources such as SQS to target services, and in cases where requests may need to be replayed for error handling |  
| _Reliability_                                   |                                                                                                                                                                                                                                                                                                                                        |                                                                                                      |
| Circuit Breaker                                 | A service proxy that stops sending requests to a service when an error threshold is reached; to help prevent a single service failure from impacting the remainder of the system                                                                                                                                                       |                                                                                                      |
| _Observability_                                 |                                                                                                                                                                                                                                                                                                                                        |                                                                                                      |
| Logging                                         |                                                                                                                                                                                                                                                                                                                                        | AWS Cloudwatch                                                                                       |
| Metrics                                         |                                                                                                                                                                                                                                                                                                                                        | AWS Cloudwatch                                                                                       |
| Distributed tracing                             |                                                                                                                                                                                                                                                                                                                                        | AWS x-ray                                                                                            |
| Health check API                                |                                                                                                                                                                                                                                                                                                                                        | AWS Cloudwatch alarms, healthcheck endpoint support e.g. Route53, Load Balancers, Autoscaling groups |


##### Infrastructure Patterns

| **Pattern**           | Description                                                                                                                                                                                                                                                                                                                                                                                           | Notes                                                                                                                                                    |
|:----------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| Service per VM        | Each service/microservice is deployed to its own virtual machine (AWS EC2 instances). Horizontal scaling of the service may be realized by spawning new instances of VM's containing the application. Note scaliing can be slow, as initializing a VM requires bootstrapping of its underlying OS and infrastructure services.                                                                        |                                                                                                                                                   |
| Serverless deployment | The hosts and OS of services/microservices are abstracted away from the implementer, and the cloud provider assumes responsibility for managing these. Typically the cloud customer simply specifies the CPU and storage units tha are required, and costs ar ebased on these and time. AWS technologies include Lambda (Function as a Service), AWS ECS (Fargate), AWS EKS (Fargate)                 | As request processing is expected to be short in duration, it is anticpated that Lambda may be predominantly used, for simplicity and optimal scalability |
| Service per container | Each service/microservice is deployed to its own docker container.  Horizontal scaling of the service may be realized by spawning new containers containing the application on a machine. In contrast to VM-based scaling, container scaling is typically fast. AWS services include: AWS ECS, AWS EKS                                                                                                |                                                                                                                                      |

